{"version":3,"file":"contentLoader-D5Fhe5uN.js","sources":["../../../src/blogs/fnf-ios-port.mdx","../../../src/blogs/hybrid-graphics-kvm-arch.mdx","../../../src/blogs/ps3-pro.mdx","../../../node_modules/marked/lib/marked.esm.js","../../../src/utils/contentLoader.ts"],"sourcesContent":["export const title = \"The First FNF iOS Port\";\nexport const date = \"2025-02-21\";\nexport const excerpt = \"My journey porting and optimizing Friday Night Funkin' for iOS devices\";\n\n<UnderConstructionNotice />\n\n<PongGame />","export const title = \"Dynamic GPU Passthrough on Muxless (or Muxed) Linux Hosts\";\nexport const date = \"2025-02-27\";\nexport const excerpt = \"Tips on achieving graphics-accelerated VMs on a muxless (or muxed!) NVIDIA PRIME hybrid graphics laptop (or desktop), all without using a silly dummy plug :)\";\nexport const thumbnail = \"/assets/img/hybrid-kvm-redmibook.png\";\n\n<ImageCarousel\n  images={[\n    {\n      src: \"/assets/img/blog-post-imgs/hybrid-graphics-kvm-arch/fastfetch-sysinfo.png\",\n      alt: \"System information output showing specifications of my (muxless) RedmiBook Pro\",\n      caption: \"System specifications from fastfetch\"\n    },\n    {\n      src: \"/assets/img/blog-post-imgs/hybrid-graphics-kvm-arch/hybrid-kvm-redmibook.png\",\n      alt: \"Windows 10 virtual machine running with NVIDIA graphics acceleration on the muxless Redmibook!\",\n      caption: \"Windows 10 virtual machine running with NVIDIA graphics acceleration on the muxless Redmibook!\"\n    }\n  ]}\n/>\n### Laptop Specifications\n\n- Model: RedmiBook Pro 15 (2021)\n- CPU: Intel i7-11370H (4 cores, 8 threads)\n- dGPU: NVIDIA MX450, 2GB VRAM\n- iGPU: Iris Xe Graphics (TGL2)\n- RAM: 16GB 3200MHz Soldered RAM :(\n- Display: 15.6\" 3200x2000 90Hz IPS (!!!)\n\n### Preamble\n\nLinux is great, but `${CURRENT_YEAR}` is still not quite the year of Linux on the desktop (or laptop, for that matter). Lots of software and games will simply never get ported to Linux, and sometimes frameworks that aim to run Windows programs on Linux like Wine and Proton aren't good enough for some software yet...\n\nThus, KVMs (kernel-based virtual machines) for Windows with GPU passthrough are desirable and oftentimes a necessity for many Linux users.\n\nOne of the biggest difficulties when setting up a Windows KVM on a hybrid graphics machines is actually being able to SEE the graphically-accelerated output from the passed-through dGPU through the host.\n\n### Requirements/Software Used\n\n- A laptop with at least two GPUs (iGPU and dGPU)\n- Linux software:\n  - I used Arch (btw) but the same general setup should work across distros?\n  - libvirtd, virt-manager, qemu, etc.\n  - [looking-glass-module-dkms](https://aur.archlinux.org/packages/looking-glass-module-dkms)\n- Windows VM software:\n  - looking-glass-host\n  - Virtual-Display-Driver\n\n### Getting our (Arch) Linux host ready\n\n> **NOTE:** These steps are largely based off the instructions outlined in the [PCI passthrough via OVMF](https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF#Binding_vfio-pci_via_device_ID) page on the Arch Linux Wiki, as well as [this great QEMU-KVM setup guide for Arch Linux](https://gist.github.com/tatumroaquin/c6464e1ccaef40fd098a4f31db61ab22) by [tatumroaquin](https://gist.github.com/tatumroaquin)!\n\n1. [Verify that IOMMU is enabled](https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF#Setting_up_IOMMU)\n2. [Ensure your IOMMU groups are valid](https://wiki.archlinux.org/title/PCI_passthrough_via_OVMF#Ensuring_that_the_groups_are_valid)\n3. [Install the necessary packages](https://gist.github.com/tatumroaquin/c6464e1ccaef40fd098a4f31db61ab22#install-qemu-libvirt-viewers-and-tools) (`sudo pacman -S qemu-desktop libvirt dnsmasq swtpm edk2-ovmf`)\n4. Add your user to the libvirt group (`sudo usermod -a -G libvirt $USER`)\n5. Uncomment and modify lines in `/etc/libvirt/qemu.conf`:\n\n<details>\n<summary>Example <code>/etc/libvirt/qemu.conf</code> changes</summary>\n\n```sh\nsudo nano /etc/libvirt/qemu.conf\n```\n```conf\n# MODIFY THE LINE BELOW TO INCLUDE YOUR $USER\nuser = \"nick\" # MODIFY THIS LINE TO INCLUDE YOUR $USER\n\n# UNCOMMENT THE BLOCK BELOW, ADD \"/dev/kvmfr0\" TO THE ARRAY LIKE SO!\ncgroup_device_acl = [\n    \"/dev/null\", \"/dev/full\", \"/dev/zero\",\n    \"/dev/random\", \"/dev/urandom\",\n    \"/dev/ptmx\", \"/dev/kvm\",\n    \"/dev/userfaultfd\", \"/dev/kvmfr0\"\n]\n# UNCOMMENT THE BLOCK ABOVE, ADD \"/dev/kvmfr0\" TO THE ARRAY LIKE SO!\n```\n</details>\n\n6. Enable & start libvirtd.service:  \n   `sudo systemctl enable --now libvirtd.service`\n7. Start the libvirt network:  \n   `sudo virsh net-autostart default`\n8. Create `/etc/modules-load.d/kvmfr.conf` to load the `kvmfr` module for Looking-Glass on boot:  \n   `sudo nano /etc/modules-load.d/kvmfr.conf`  \n   Contents:\n   ```\n   # KVMFR Looking Glass module\n   kvmfr\n   ```\n9. Create `/etc/modprobe.d/kvmfr.conf` to set the framebuffer size on boot (Calculate framebuffer size [here](https://looking-glass.io/docs/B7/install_libvirt/#determining-memory)):  \n   `sudo nano /etc/modprobe.d/kvmfr.conf`  \n   Contents:\n   ```\n   options kvmfr static_size_mb=64\n   ```\n10. Create `99-kvmfr.rules` udev rule to correct kvmfr0 permissions:  \n    `sudo nano /etc/udev/rules.d/99-kvmfr.rules`  \n    Contents:\n    ```\n    # REPLACE $USER WITH YOUR USERNAME!!\n    SUBSYSTEM==\"kvmfr\", OWNER=\"$USER\", GROUP=\"kvm\", MODE=\"0660\"\n    ```\n11. Run the following or just rebuild initramfs & reboot:  \n    `sudo modprobe kvmfr static_size_mb=64`\n12. Create Windows VM using `virt-manager`, but don't attach the dGPU yet!\n\n### Setting up dynamically unbinding the NVIDIA GPU from the Linux host\n\n[Set up QEMU hooks](https://passthroughpo.st/simple-per-vm-libvirt-hooks-with-the-vfio-tools-hook-helper/) by simply creating the `hooks` directory and running the script provided by PassthroughPOST:\n\n```sh\nsudo mkdir -p /etc/libvirt/hooks\nsudo wget 'https://raw.githubusercontent.com/PassthroughPOST/VFIO-Tools/master/libvirt_hooks/qemu' -O /etc/libvirt/hooks/qemu\nsudo chmod +x /etc/libvirt/hooks/qemu\n```\n\nThen, create a folder at `/etc/libvirt/hooks/qemu.d/` with the name of the VM you created earlier.\n\nFor example, let's say you named your VM `Windows-11`:\n\n```bash\nsudo mkdir -p /etc/libvirt/hooks/qemu.d/Windows-11/\n```\n\nCreate the folders for the begin and end hooks:\n\n```bash\nsudo mkdir -p /etc/libvirt/hooks/qemu.d/${VMNAME}/prepare/begin\nsudo mkdir -p /etc/libvirt/hooks/qemu.d/${VMNAME}/release/end\n```\n\nFinally, we can create our start and stop scripts:\n\n**prepare/begin/start.sh**\n```sh\n#!/bin/bash\n# Unload NVIDIA Modules\nmodprobe -r nvidia_uvm nvidia_drm nvidia_modeset nvidia\n# stop nvidia-persistenced\nsystemctl stop nvidia-persistenced.service\n```\n\n**release/end/stop.sh**\n```sh\n#!/bin/bash\n# Re-load NVIDIA Modules\nmodprobe nvidia\nsleep 1\nmodprobe nvidia_modeset\nsleep 1\nmodprobe nvidia_uvm\nsleep 1\nmodprobe nvidia_drm\nsleep 1\n# (re)start nvidia-persistenced\nsystemctl start nvidia-persistenced\n```\n\nMake these scripts executable:\n\n```sh\nchmod +x /etc/libvirt/hooks/qemu.d/${VMNAME}/prepare/begin/start.sh\nchmod +x /etc/libvirt/hooks/qemu.d/${VMNAME}/release/end/stop.sh\n```\n\nRestart libvirtd:\n\n```sh\nsudo systemctl restart libvirtd\n```\n\nAdd the NVIDIA dGPU PCI device(s) to your VM using `virt-manager`!\n\nStarting the VM with these scripts should successfully 'unload' the NVIDIA GPU from Linux and 'give it' to the Windows VM!\nNo need to touch `vfio_pci` drivers... :)\n\n## Getting accelerated video output through Looking-Glass without a physical dummy plug using Virtual Display Driver (VDD)\n\nOnce your Windows VM can boot with the NVIDIA card attached, use the SPICE/VGA video passthrough through `virt-manager` to complete the Windows setup and install the NVIDIA graphics drivers.\n\nOnce the NVIDIA drivers are installed, download and install the latest releases of [Looking-Glass-Host](https://looking-glass.io/downloads) and [Virtual-Display-Driver](https://github.com/VirtualDisplay/Virtual-Display-Driver/releases/latest).\n\nHere's the weird part. In my experience, simply removing the SPICE video devices from the VM via `virt-manager` would result in Looking-Glass giving a blank/black picture, regardless of which display was set default in Windows, etc.\n\nI worked around this by doing the following, in this order:\n- Right clicked the desktop to get to Display Settings (or go to Windows Settings > System > Display Settings)\n- Determined which output/screen index corresponded to either SPICE or the Virtual Display by going to 'Advanced Display' ('Wired Monitor' is usually SPICE, Virtual Display Driver should be obvious by its name)\n- For this example, we will assume that SPICE = Display 1, VDD = Display 2.\n- Select the option to show only on the Virtual Display Device. So, if VDD is Display 2, select 'Show only on 2'.\n- Both screens (Looking-Glass AND SPICE via `virt-manager`) SHOULD BE BLACK.\n- QUICKLY* turn off the VM via `virt-manager` (through the host), and turn it back on once it's powered off fully. (*do it within ~15 seconds to prevent Windows from undoing the changes)\n- Upon the next boot, Looking-Glass should be the only 'display' active. This display should have functioning graphics acceleration via the NVIDIA card unlike the regular old SPICE window, all without a physical dummy connector!\n\nThere's probably a more elegant way of disabling the SPICE monitor to enable proper output via Looking-Glasss, but this worked for me.\n\n### WHY are we doing this?\n\nThe most common solution in the past was to use a HDMI/DisplayPort dummy display plug plugged into one of the laptop's dGPU outputs, 'simulating' a display for the passed-through dGPU to render to, alongside Looking-Glass to then mirror that accelerated 'display' from the guest to the host's internal display on Linux through the Looking-Glass client. Another solution was to simply just not use the internal display for KVMs when doing accelerated passthrough at all and to use an external display plugged into the laptop for KVMs.\n\nThese solutions work, but... they either require the purchase & constant use of a physical dummy plug, or the reliance on an external monitor when using our Windows KVM. There's nothing wrong with this, but these solutions aren't quite 'elegant' and do not work for muxless laptops.\n\n### Muxless? Muxed?\n\nThe laptop I use to demonstrate this is *muxless*, meaning that ALL graphics/video/display shown on the internal and external displays are 'presented' using the iGPU. That means that even if the NVIDIA dGPU is rendering something, the NVIDIA dGPU 'relies' on the Intel iGPU to actually 'show' what it's doing.\n\nA *muxed* laptop, on the other hand, supports dynamic switching between the iGPU/dGPU for the internal and external displays. Muxed laptops are often regarded as being 'better' for KVMs and GPU passthrough vs. muxless laptops, however, in my experience, both setups have very similar difficulties that are solved largely in the same ways, and neither is 'objectively better' for the purposes of running a graphically-accelerated KVM (in my experience).\n\nPRACTICALLY SPEAKING... the 'method'/strategy we will be using in this guide to get graphically accelerated output from our Windows KVM should work whether you have a muxed or muxless laptop!\n\n### Solving `modprobe: FATAL: Module nvidia_drm is in use`\n\n#### PROBLEM:\nSome applications use `nvidia_drm` unexpectedly, therefore not allowing the `start.sh` QEMU hook to run correctly. This problem could be a symptom of another issue with my configuration and could possibly be solved a 'better' way, but this solution works well enough for me:\n\n```sh\nsudo modprobe -r nvidia_drm\n# modprobe: FATAL: Module nvidia_drm is in use.\n```\n\nRunning `sudo lsmod | grep nvidia` revealed that 2 processes that were using `nvidia_drm`:\n\n```sh\nsudo lsmod | grep -iE nvidia\nnvidia_drm            139264  2\nnvidia_modeset       1830912  1 nvidia_drm\nnvidia              96956416  6 nvidia_modeset\ndrm_ttm_helper         16384  2 nvidia_drm,xe\nvideo                  81920  3 xe,i915,nvidia_modeset\n```\n\nRunning `sudo lsof | grep -iE nvidia` gave me the list/history of processes that have run on the NVIDIA driver. I saw a whole bunch of entries for `electron`. I closed all Electron apps running (Discord, Mullvad VPN, Beeper etc.) and re-ran `sudo lsmod | grep nvidia`:\n\n```sh\nnick@hybrid:~$ sudo lsmod | grep -iE nvidia\nnvidia_uvm           3977216  0\nnvidia_drm            139264  0\nnvidia_modeset       1830912  1 nvidia_drm\nnvidia              96956416  2 nvidia_uvm,nvidia_modeset\ndrm_ttm_helper         16384  2 nvidia_drm,xe\nvideo                  81920  3 xe,i915,nvidia_modeset\n```\n\nNow `nvidia_drm` is being used by 0 processes, so we can now unload `nvidia` drivers successfully:\n\n```sh\nnick@hybrid:~$ sudo modprobe -r nvidia_uvm nvidia_drm nvidia_modeset nvidia \n\nnick@hybrid:~$ \n```\n\nMy solution is kinda lazy, but works well enough for me. For each application that was using `nvidia_drm`, I added `VK_ICD_FILENAMES=/usr/share/vulkan/icd.d/intel_icd.x86_64.json` to the `Environment variables` of Discord*, Mullvad VPN and Beeper. For more 'stubbourn' programs, I simply add a `pkill` line for that program to the `start.sh` script of my VM, and you can even automatically restart the `pkill`'d application using another QEMU hook!\n\nContents of `/etc.modprobe.d/nvidia.conf`:\n```conf\noptions nvidia \"NVreg_EnableGpuFirmware=0\"\n```\n\nThese options disable (part of?) the NVIDIA GPU firmware? Without this option, the card would stay in D0 and never enter D3cold.\n\n```sh\nnick@hybrid:~$ sudo cat /proc/driver/nvidia/gpus/0000:2b:00.0/power\nRuntime D3 status:          Enabled (fine-grained)\nVideo Memory:               Off\n\nGPU Hardware Support:\n Video Memory Self Refresh: Supported\n Video Memory Off:          Supported\n\nS0ix Power Management:\n Platform Support:          Supported\n Status:                    Disabled\n\nNotebook Dynamic Boost:     Not Supported","export const title = \"How I Built a 'PS3 Pro'\";\nexport const date = \"2025-02-22\";\nexport const excerpt = \"How far can we push Sony's best console?\";\n\n<UnderConstructionNotice />\n\n<PongGame />\n","/**\n * marked v15.0.7 - a markdown parser\n * Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n/**\n * Gets the original marked default options.\n */\nfunction _getDefaults() {\n    return {\n        async: false,\n        breaks: false,\n        extensions: null,\n        gfm: true,\n        hooks: null,\n        pedantic: false,\n        renderer: null,\n        silent: false,\n        tokenizer: null,\n        walkTokens: null,\n    };\n}\nlet _defaults = _getDefaults();\nfunction changeDefaults(newDefaults) {\n    _defaults = newDefaults;\n}\n\nconst noopTest = { exec: () => null };\nfunction edit(regex, opt = '') {\n    let source = typeof regex === 'string' ? regex : regex.source;\n    const obj = {\n        replace: (name, val) => {\n            let valSource = typeof val === 'string' ? val : val.source;\n            valSource = valSource.replace(other.caret, '$1');\n            source = source.replace(name, valSource);\n            return obj;\n        },\n        getRegex: () => {\n            return new RegExp(source, opt);\n        },\n    };\n    return obj;\n}\nconst other = {\n    codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n    outputLinkReplace: /\\\\([\\[\\]])/g,\n    indentCodeCompensation: /^(\\s+)(?:```)/,\n    beginningSpace: /^\\s+/,\n    endingHash: /#$/,\n    startingSpaceChar: /^ /,\n    endingSpaceChar: / $/,\n    nonSpaceChar: /[^ ]/,\n    newLineCharGlobal: /\\n/g,\n    tabCharGlobal: /\\t/g,\n    multipleSpaceGlobal: /\\s+/g,\n    blankLine: /^[ \\t]*$/,\n    doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n    blockquoteStart: /^ {0,3}>/,\n    blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n    blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n    listReplaceTabs: /^\\t+/,\n    listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n    listIsTask: /^\\[[ xX]\\] /,\n    listReplaceTask: /^\\[[ xX]\\] +/,\n    anyLine: /\\n.*\\n/,\n    hrefBrackets: /^<(.*)>$/,\n    tableDelimiter: /[:|]/,\n    tableAlignChars: /^\\||\\| *$/g,\n    tableRowBlankLine: /\\n[ \\t]*$/,\n    tableAlignRight: /^ *-+: *$/,\n    tableAlignCenter: /^ *:-+: *$/,\n    tableAlignLeft: /^ *:-+ *$/,\n    startATag: /^<a /i,\n    endATag: /^<\\/a>/i,\n    startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n    endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n    startAngleBracket: /^</,\n    endAngleBracket: />$/,\n    pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n    unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n    escapeTest: /[&<>\"']/,\n    escapeReplace: /[&<>\"']/g,\n    escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n    escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n    unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n    caret: /(^|[^\\[])\\^/g,\n    percentDecode: /%25/g,\n    findPipe: /\\|/g,\n    splitPipe: / \\|/,\n    slashPipe: /\\\\\\|/g,\n    carriageReturn: /\\r\\n|\\r/g,\n    spaceLine: /^ +$/gm,\n    notSpaceStart: /^\\S*/,\n    endingNewline: /\\n$/,\n    listItemRegex: (bull) => new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`),\n    nextBulletRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),\n    hrRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n    fencesBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`),\n    headingBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),\n    htmlBeginRegex: (indent) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i'),\n};\n/**\n * Block-Level Grammar\n */\nconst newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/;\nconst lheading = edit(lheadingCore)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .replace(/\\|table/g, '') // table not in commonmark\n    .getRegex();\nconst lheadingGfm = edit(lheadingCore)\n    .replace(/bull/g, bullet) // lists can interrupt\n    .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n    .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n    .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n    .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n    .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n    .replace(/table/g, / {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/) // table can interrupt\n    .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n    .replace('label', _blockLabel)\n    .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n    .getRegex();\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n    .replace(/bull/g, bullet)\n    .getRegex();\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n    + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n    + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n    + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n    + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n    + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit('^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n    + '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n    + '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n    + ')', 'i')\n    .replace('comment', _comment)\n    .replace('tag', _tag)\n    .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst paragraph = edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n    .replace('paragraph', paragraph)\n    .getRegex();\n/**\n * Normal Block Grammar\n */\nconst blockNormal = {\n    blockquote,\n    code: blockCode,\n    def,\n    fences,\n    heading,\n    hr,\n    html,\n    lheading,\n    list,\n    newline,\n    paragraph,\n    table: noopTest,\n    text: blockText,\n};\n/**\n * GFM Block Grammar\n */\nconst gfmTable = edit('^ *([^\\\\n ].*)\\\\n' // Header\n    + ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n    + '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('blockquote', ' {0,3}>')\n    .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n    .getRegex();\nconst blockGfm = {\n    ...blockNormal,\n    lheading: lheadingGfm,\n    table: gfmTable,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n        .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n        .replace('table', gfmTable) // interrupt paragraphs with table\n        .replace('blockquote', ' {0,3}>')\n        .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n        .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n        .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n        .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n        .getRegex(),\n};\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\nconst blockPedantic = {\n    ...blockNormal,\n    html: edit('^ *(?:comment *(?:\\\\n|\\\\s*$)'\n        + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n        + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n        .replace('comment', _comment)\n        .replace(/tag/g, '(?!(?:'\n        + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n        + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n        + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n        .getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest, // fences not supported\n    lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    paragraph: edit(_paragraph)\n        .replace('hr', hr)\n        .replace('heading', ' *#{1,6} *[^\\n]')\n        .replace('lheading', lheading)\n        .replace('|table', '')\n        .replace('blockquote', ' {0,3}>')\n        .replace('|fences', '')\n        .replace('|list', '')\n        .replace('|html', '')\n        .replace('|tag', '')\n        .getRegex(),\n};\n/**\n * Inline-Level Grammar\n */\nconst escape$1 = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = /[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpace = /[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpace = /[^\\s\\p{P}\\p{S}]/u;\nconst punctuation = edit(/^((?![*_])punctSpace)/, 'u')\n    .replace(/punctSpace/g, _punctuationOrSpace).getRegex();\n// GFM allows ~ inside strong and em for strikethrough\nconst _punctuationGfmStrongEm = /(?!~)[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpaceGfmStrongEm = /(?!~)[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpaceGfmStrongEm = /(?:[^\\s\\p{P}\\p{S}]|~)/u;\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\nconst emStrongLDelimCore = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/;\nconst emStrongLDelim = edit(emStrongLDelimCore, 'u')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')\n    .replace(/punct/g, _punctuationGfmStrongEm)\n    .getRegex();\nconst emStrongRDelimAstCore = '^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n    + '|[^*]+(?=[^*])' // Consume to delim\n    + '|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n    + '|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)' // (2) a***#, a*** can only be a Right Delimiter\n    + '|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)' // (3) #***a, ***a can only be Left Delimiter\n    + '|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)' // (4) ***# can only be Left Delimiter\n    + '|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)' // (5) #***# can be either Left or Right Delimiter\n    + '|notPunctSpace(\\\\*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter\nconst emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')\n    .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n    .replace(/punctSpace/g, _punctuationOrSpace)\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')\n    .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)\n    .replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)\n    .replace(/punct/g, _punctuationGfmStrongEm)\n    .getRegex();\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit('^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n    + '|[^_]+(?=[^_])' // Consume to delim\n    + '|(?!_)punct(_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n    + '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' // (2) a___#, a___ can only be a Right Delimiter\n    + '|(?!_)punctSpace(_+)(?=notPunctSpace)' // (3) #___a, ___a can only be Left Delimiter\n    + '|[\\\\s](_+)(?!_)(?=punct)' // (4) ___# can only be Left Delimiter\n    + '|(?!_)punct(_+)(?!_)(?=punct)', 'gu') // (5) #___# can be either Left or Right Delimiter\n    .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n    .replace(/punctSpace/g, _punctuationOrSpace)\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst anyPunctuation = edit(/\\\\(punct)/, 'gu')\n    .replace(/punct/g, _punctuation)\n    .getRegex();\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n    .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n    .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n    .getRegex();\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit('^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n    .replace('comment', _inlineComment)\n    .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n    .getRegex();\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/)\n    .replace('label', _inlineLabel)\n    .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/)\n    .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n    .getRegex();\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n    .replace('label', _inlineLabel)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n    .replace('ref', _blockLabel)\n    .getRegex();\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n    .replace('reflink', reflink)\n    .replace('nolink', nolink)\n    .getRegex();\n/**\n * Normal Inline Grammar\n */\nconst inlineNormal = {\n    _backpedal: noopTest, // only used for GFM url\n    anyPunctuation,\n    autolink,\n    blockSkip,\n    br,\n    code: inlineCode,\n    del: noopTest,\n    emStrongLDelim,\n    emStrongRDelimAst,\n    emStrongRDelimUnd,\n    escape: escape$1,\n    link,\n    nolink,\n    punctuation,\n    reflink,\n    reflinkSearch,\n    tag,\n    text: inlineText,\n    url: noopTest,\n};\n/**\n * Pedantic Inline Grammar\n */\nconst inlinePedantic = {\n    ...inlineNormal,\n    link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n    reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n        .replace('label', _inlineLabel)\n        .getRegex(),\n};\n/**\n * GFM Inline Grammar\n */\nconst inlineGfm = {\n    ...inlineNormal,\n    emStrongRDelimAst: emStrongRDelimAstGfm,\n    emStrongLDelim: emStrongLDelimGfm,\n    url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n        .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n        .getRegex(),\n    _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n};\n/**\n * GFM + Line Breaks Inline Grammar\n */\nconst inlineBreaks = {\n    ...inlineGfm,\n    br: edit(br).replace('{2,}', '*').getRegex(),\n    text: edit(inlineGfm.text)\n        .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n        .replace(/\\{2,\\}/g, '*')\n        .getRegex(),\n};\n/**\n * exports\n */\nconst block = {\n    normal: blockNormal,\n    gfm: blockGfm,\n    pedantic: blockPedantic,\n};\nconst inline = {\n    normal: inlineNormal,\n    gfm: inlineGfm,\n    breaks: inlineBreaks,\n    pedantic: inlinePedantic,\n};\n\n/**\n * Helpers\n */\nconst escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;',\n};\nconst getEscapeReplacement = (ch) => escapeReplacements[ch];\nfunction escape(html, encode) {\n    if (encode) {\n        if (other.escapeTest.test(html)) {\n            return html.replace(other.escapeReplace, getEscapeReplacement);\n        }\n    }\n    else {\n        if (other.escapeTestNoEncode.test(html)) {\n            return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n        }\n    }\n    return html;\n}\nfunction cleanUrl(href) {\n    try {\n        href = encodeURI(href).replace(other.percentDecode, '%');\n    }\n    catch {\n        return null;\n    }\n    return href;\n}\nfunction splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    const row = tableRow.replace(other.findPipe, (match, offset, str) => {\n        let escaped = false;\n        let curr = offset;\n        while (--curr >= 0 && str[curr] === '\\\\')\n            escaped = !escaped;\n        if (escaped) {\n            // odd number of slashes means | is escaped\n            // so we leave it alone\n            return '|';\n        }\n        else {\n            // add space before unescaped |\n            return ' |';\n        }\n    }), cells = row.split(other.splitPipe);\n    let i = 0;\n    // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n    if (!cells[0].trim()) {\n        cells.shift();\n    }\n    if (cells.length > 0 && !cells.at(-1)?.trim()) {\n        cells.pop();\n    }\n    if (count) {\n        if (cells.length > count) {\n            cells.splice(count);\n        }\n        else {\n            while (cells.length < count)\n                cells.push('');\n        }\n    }\n    for (; i < cells.length; i++) {\n        // leading or trailing whitespace is ignored per the gfm spec\n        cells[i] = cells[i].trim().replace(other.slashPipe, '|');\n    }\n    return cells;\n}\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nfunction rtrim(str, c, invert) {\n    const l = str.length;\n    if (l === 0) {\n        return '';\n    }\n    // Length of suffix matching the invert condition.\n    let suffLen = 0;\n    // Step left until we fail to match the invert condition.\n    while (suffLen < l) {\n        const currChar = str.charAt(l - suffLen - 1);\n        if (currChar === c && true) {\n            suffLen++;\n        }\n        else {\n            break;\n        }\n    }\n    return str.slice(0, l - suffLen);\n}\nfunction findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n        return -1;\n    }\n    let level = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str[i] === '\\\\') {\n            i++;\n        }\n        else if (str[i] === b[0]) {\n            level++;\n        }\n        else if (str[i] === b[1]) {\n            level--;\n            if (level < 0) {\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n\nfunction outputLink(cap, link, raw, lexer, rules) {\n    const href = link.href;\n    const title = link.title || null;\n    const text = cap[1].replace(rules.other.outputLinkReplace, '$1');\n    if (cap[0].charAt(0) !== '!') {\n        lexer.state.inLink = true;\n        const token = {\n            type: 'link',\n            raw,\n            href,\n            title,\n            text,\n            tokens: lexer.inlineTokens(text),\n        };\n        lexer.state.inLink = false;\n        return token;\n    }\n    return {\n        type: 'image',\n        raw,\n        href,\n        title,\n        text,\n    };\n}\nfunction indentCodeCompensation(raw, text, rules) {\n    const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n    if (matchIndentToCode === null) {\n        return text;\n    }\n    const indentToCode = matchIndentToCode[1];\n    return text\n        .split('\\n')\n        .map(node => {\n        const matchIndentInNode = node.match(rules.other.beginningSpace);\n        if (matchIndentInNode === null) {\n            return node;\n        }\n        const [indentInNode] = matchIndentInNode;\n        if (indentInNode.length >= indentToCode.length) {\n            return node.slice(indentToCode.length);\n        }\n        return node;\n    })\n        .join('\\n');\n}\n/**\n * Tokenizer\n */\nclass _Tokenizer {\n    options;\n    rules; // set by the lexer\n    lexer; // set by the lexer\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(src) {\n        const cap = this.rules.block.newline.exec(src);\n        if (cap && cap[0].length > 0) {\n            return {\n                type: 'space',\n                raw: cap[0],\n            };\n        }\n    }\n    code(src) {\n        const cap = this.rules.block.code.exec(src);\n        if (cap) {\n            const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');\n            return {\n                type: 'code',\n                raw: cap[0],\n                codeBlockStyle: 'indented',\n                text: !this.options.pedantic\n                    ? rtrim(text, '\\n')\n                    : text,\n            };\n        }\n    }\n    fences(src) {\n        const cap = this.rules.block.fences.exec(src);\n        if (cap) {\n            const raw = cap[0];\n            const text = indentCodeCompensation(raw, cap[3] || '', this.rules);\n            return {\n                type: 'code',\n                raw,\n                lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n                text,\n            };\n        }\n    }\n    heading(src) {\n        const cap = this.rules.block.heading.exec(src);\n        if (cap) {\n            let text = cap[2].trim();\n            // remove trailing #s\n            if (this.rules.other.endingHash.test(text)) {\n                const trimmed = rtrim(text, '#');\n                if (this.options.pedantic) {\n                    text = trimmed.trim();\n                }\n                else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {\n                    // CommonMark requires space before trailing #s\n                    text = trimmed.trim();\n                }\n            }\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[1].length,\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    hr(src) {\n        const cap = this.rules.block.hr.exec(src);\n        if (cap) {\n            return {\n                type: 'hr',\n                raw: rtrim(cap[0], '\\n'),\n            };\n        }\n    }\n    blockquote(src) {\n        const cap = this.rules.block.blockquote.exec(src);\n        if (cap) {\n            let lines = rtrim(cap[0], '\\n').split('\\n');\n            let raw = '';\n            let text = '';\n            const tokens = [];\n            while (lines.length > 0) {\n                let inBlockquote = false;\n                const currentLines = [];\n                let i;\n                for (i = 0; i < lines.length; i++) {\n                    // get lines up to a continuation\n                    if (this.rules.other.blockquoteStart.test(lines[i])) {\n                        currentLines.push(lines[i]);\n                        inBlockquote = true;\n                    }\n                    else if (!inBlockquote) {\n                        currentLines.push(lines[i]);\n                    }\n                    else {\n                        break;\n                    }\n                }\n                lines = lines.slice(i);\n                const currentRaw = currentLines.join('\\n');\n                const currentText = currentRaw\n                    // precede setext continuation with 4 spaces so it isn't a setext\n                    .replace(this.rules.other.blockquoteSetextReplace, '\\n    $1')\n                    .replace(this.rules.other.blockquoteSetextReplace2, '');\n                raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n                text = text ? `${text}\\n${currentText}` : currentText;\n                // parse blockquote lines as top level tokens\n                // merge paragraphs if this is a continuation\n                const top = this.lexer.state.top;\n                this.lexer.state.top = true;\n                this.lexer.blockTokens(currentText, tokens, true);\n                this.lexer.state.top = top;\n                // if there is no continuation then we are done\n                if (lines.length === 0) {\n                    break;\n                }\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'code') {\n                    // blockquote continuation cannot be preceded by a code block\n                    break;\n                }\n                else if (lastToken?.type === 'blockquote') {\n                    // include continuation in nested blockquote\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.blockquote(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n                    break;\n                }\n                else if (lastToken?.type === 'list') {\n                    // include continuation in nested list\n                    const oldToken = lastToken;\n                    const newText = oldToken.raw + '\\n' + lines.join('\\n');\n                    const newToken = this.list(newText);\n                    tokens[tokens.length - 1] = newToken;\n                    raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n                    text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n                    lines = newText.substring(tokens.at(-1).raw.length).split('\\n');\n                    continue;\n                }\n            }\n            return {\n                type: 'blockquote',\n                raw,\n                tokens,\n                text,\n            };\n        }\n    }\n    list(src) {\n        let cap = this.rules.block.list.exec(src);\n        if (cap) {\n            let bull = cap[1].trim();\n            const isordered = bull.length > 1;\n            const list = {\n                type: 'list',\n                raw: '',\n                ordered: isordered,\n                start: isordered ? +bull.slice(0, -1) : '',\n                loose: false,\n                items: [],\n            };\n            bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n            if (this.options.pedantic) {\n                bull = isordered ? bull : '[*+-]';\n            }\n            // Get next list item\n            const itemRegex = this.rules.other.listItemRegex(bull);\n            let endsWithBlankLine = false;\n            // Check if current bullet point can start a new List Item\n            while (src) {\n                let endEarly = false;\n                let raw = '';\n                let itemContents = '';\n                if (!(cap = itemRegex.exec(src))) {\n                    break;\n                }\n                if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n                    break;\n                }\n                raw = cap[0];\n                src = src.substring(raw.length);\n                let line = cap[2].split('\\n', 1)[0].replace(this.rules.other.listReplaceTabs, (t) => ' '.repeat(3 * t.length));\n                let nextLine = src.split('\\n', 1)[0];\n                let blankLine = !line.trim();\n                let indent = 0;\n                if (this.options.pedantic) {\n                    indent = 2;\n                    itemContents = line.trimStart();\n                }\n                else if (blankLine) {\n                    indent = cap[1].length + 1;\n                }\n                else {\n                    indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char\n                    indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n                    itemContents = line.slice(indent);\n                    indent += cap[1].length;\n                }\n                if (blankLine && this.rules.other.blankLine.test(nextLine)) { // Items begin with at most one blank line\n                    raw += nextLine + '\\n';\n                    src = src.substring(nextLine.length + 1);\n                    endEarly = true;\n                }\n                if (!endEarly) {\n                    const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n                    const hrRegex = this.rules.other.hrRegex(indent);\n                    const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n                    const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n                    const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n                    // Check if following lines should be included in List Item\n                    while (src) {\n                        const rawLine = src.split('\\n', 1)[0];\n                        let nextLineWithoutTabs;\n                        nextLine = rawLine;\n                        // Re-align to follow commonmark nesting rules\n                        if (this.options.pedantic) {\n                            nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');\n                            nextLineWithoutTabs = nextLine;\n                        }\n                        else {\n                            nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');\n                        }\n                        // End list item if found code fences\n                        if (fencesBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new heading\n                        if (headingBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of html block\n                        if (htmlBeginRegex.test(nextLine)) {\n                            break;\n                        }\n                        // End list item if found start of new bullet\n                        if (nextBulletRegex.test(nextLine)) {\n                            break;\n                        }\n                        // Horizontal rule found\n                        if (hrRegex.test(nextLine)) {\n                            break;\n                        }\n                        if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) { // Dedent if possible\n                            itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n                        }\n                        else {\n                            // not enough indentation\n                            if (blankLine) {\n                                break;\n                            }\n                            // paragraph continuation unless last line was a different block level element\n                            if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) { // indented code block\n                                break;\n                            }\n                            if (fencesBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (headingBeginRegex.test(line)) {\n                                break;\n                            }\n                            if (hrRegex.test(line)) {\n                                break;\n                            }\n                            itemContents += '\\n' + nextLine;\n                        }\n                        if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n                            blankLine = true;\n                        }\n                        raw += rawLine + '\\n';\n                        src = src.substring(rawLine.length + 1);\n                        line = nextLineWithoutTabs.slice(indent);\n                    }\n                }\n                if (!list.loose) {\n                    // If the previous item ended with a blank line, the list is loose\n                    if (endsWithBlankLine) {\n                        list.loose = true;\n                    }\n                    else if (this.rules.other.doubleBlankLine.test(raw)) {\n                        endsWithBlankLine = true;\n                    }\n                }\n                let istask = null;\n                let ischecked;\n                // Check for task list items\n                if (this.options.gfm) {\n                    istask = this.rules.other.listIsTask.exec(itemContents);\n                    if (istask) {\n                        ischecked = istask[0] !== '[ ] ';\n                        itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');\n                    }\n                }\n                list.items.push({\n                    type: 'list_item',\n                    raw,\n                    task: !!istask,\n                    checked: ischecked,\n                    loose: false,\n                    text: itemContents,\n                    tokens: [],\n                });\n                list.raw += raw;\n            }\n            // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n            const lastItem = list.items.at(-1);\n            if (lastItem) {\n                lastItem.raw = lastItem.raw.trimEnd();\n                lastItem.text = lastItem.text.trimEnd();\n            }\n            else {\n                // not a list since there were no items\n                return;\n            }\n            list.raw = list.raw.trimEnd();\n            // Item child tokens handled here at end because we needed to have the final item to trim it first\n            for (let i = 0; i < list.items.length; i++) {\n                this.lexer.state.top = false;\n                list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n                if (!list.loose) {\n                    // Check if list should be loose\n                    const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n                    const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => this.rules.other.anyLine.test(t.raw));\n                    list.loose = hasMultipleLineBreaks;\n                }\n            }\n            // Set all items to loose if list is loose\n            if (list.loose) {\n                for (let i = 0; i < list.items.length; i++) {\n                    list.items[i].loose = true;\n                }\n            }\n            return list;\n        }\n    }\n    html(src) {\n        const cap = this.rules.block.html.exec(src);\n        if (cap) {\n            const token = {\n                type: 'html',\n                block: true,\n                raw: cap[0],\n                pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n                text: cap[0],\n            };\n            return token;\n        }\n    }\n    def(src) {\n        const cap = this.rules.block.def.exec(src);\n        if (cap) {\n            const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');\n            const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n            const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n            return {\n                type: 'def',\n                tag,\n                raw: cap[0],\n                href,\n                title,\n            };\n        }\n    }\n    table(src) {\n        const cap = this.rules.block.table.exec(src);\n        if (!cap) {\n            return;\n        }\n        if (!this.rules.other.tableDelimiter.test(cap[2])) {\n            // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n            return;\n        }\n        const headers = splitCells(cap[1]);\n        const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');\n        const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\\n') : [];\n        const item = {\n            type: 'table',\n            raw: cap[0],\n            header: [],\n            align: [],\n            rows: [],\n        };\n        if (headers.length !== aligns.length) {\n            // header and align columns must be equal, rows can be different.\n            return;\n        }\n        for (const align of aligns) {\n            if (this.rules.other.tableAlignRight.test(align)) {\n                item.align.push('right');\n            }\n            else if (this.rules.other.tableAlignCenter.test(align)) {\n                item.align.push('center');\n            }\n            else if (this.rules.other.tableAlignLeft.test(align)) {\n                item.align.push('left');\n            }\n            else {\n                item.align.push(null);\n            }\n        }\n        for (let i = 0; i < headers.length; i++) {\n            item.header.push({\n                text: headers[i],\n                tokens: this.lexer.inline(headers[i]),\n                header: true,\n                align: item.align[i],\n            });\n        }\n        for (const row of rows) {\n            item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n                return {\n                    text: cell,\n                    tokens: this.lexer.inline(cell),\n                    header: false,\n                    align: item.align[i],\n                };\n            }));\n        }\n        return item;\n    }\n    lheading(src) {\n        const cap = this.rules.block.lheading.exec(src);\n        if (cap) {\n            return {\n                type: 'heading',\n                raw: cap[0],\n                depth: cap[2].charAt(0) === '=' ? 1 : 2,\n                text: cap[1],\n                tokens: this.lexer.inline(cap[1]),\n            };\n        }\n    }\n    paragraph(src) {\n        const cap = this.rules.block.paragraph.exec(src);\n        if (cap) {\n            const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n                ? cap[1].slice(0, -1)\n                : cap[1];\n            return {\n                type: 'paragraph',\n                raw: cap[0],\n                text,\n                tokens: this.lexer.inline(text),\n            };\n        }\n    }\n    text(src) {\n        const cap = this.rules.block.text.exec(src);\n        if (cap) {\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                tokens: this.lexer.inline(cap[0]),\n            };\n        }\n    }\n    escape(src) {\n        const cap = this.rules.inline.escape.exec(src);\n        if (cap) {\n            return {\n                type: 'escape',\n                raw: cap[0],\n                text: cap[1],\n            };\n        }\n    }\n    tag(src) {\n        const cap = this.rules.inline.tag.exec(src);\n        if (cap) {\n            if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {\n                this.lexer.state.inLink = true;\n            }\n            else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {\n                this.lexer.state.inLink = false;\n            }\n            if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {\n                this.lexer.state.inRawBlock = true;\n            }\n            else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {\n                this.lexer.state.inRawBlock = false;\n            }\n            return {\n                type: 'html',\n                raw: cap[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: false,\n                text: cap[0],\n            };\n        }\n    }\n    link(src) {\n        const cap = this.rules.inline.link.exec(src);\n        if (cap) {\n            const trimmedUrl = cap[2].trim();\n            if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {\n                // commonmark requires matching angle brackets\n                if (!(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n                    return;\n                }\n                // ending angle bracket cannot be escaped\n                const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n                if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n                    return;\n                }\n            }\n            else {\n                // find closing parenthesis\n                const lastParenIndex = findClosingBracket(cap[2], '()');\n                if (lastParenIndex > -1) {\n                    const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n                    const linkLen = start + cap[1].length + lastParenIndex;\n                    cap[2] = cap[2].substring(0, lastParenIndex);\n                    cap[0] = cap[0].substring(0, linkLen).trim();\n                    cap[3] = '';\n                }\n            }\n            let href = cap[2];\n            let title = '';\n            if (this.options.pedantic) {\n                // split pedantic href and title\n                const link = this.rules.other.pedanticHrefTitle.exec(href);\n                if (link) {\n                    href = link[1];\n                    title = link[3];\n                }\n            }\n            else {\n                title = cap[3] ? cap[3].slice(1, -1) : '';\n            }\n            href = href.trim();\n            if (this.rules.other.startAngleBracket.test(href)) {\n                if (this.options.pedantic && !(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n                    // pedantic allows starting angle bracket without ending angle bracket\n                    href = href.slice(1);\n                }\n                else {\n                    href = href.slice(1, -1);\n                }\n            }\n            return outputLink(cap, {\n                href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n                title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n            }, cap[0], this.lexer, this.rules);\n        }\n    }\n    reflink(src, links) {\n        let cap;\n        if ((cap = this.rules.inline.reflink.exec(src))\n            || (cap = this.rules.inline.nolink.exec(src))) {\n            const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');\n            const link = links[linkString.toLowerCase()];\n            if (!link) {\n                const text = cap[0].charAt(0);\n                return {\n                    type: 'text',\n                    raw: text,\n                    text,\n                };\n            }\n            return outputLink(cap, link, cap[0], this.lexer, this.rules);\n        }\n    }\n    emStrong(src, maskedSrc, prevChar = '') {\n        let match = this.rules.inline.emStrongLDelim.exec(src);\n        if (!match)\n            return;\n        // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n        if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric))\n            return;\n        const nextChar = match[1] || match[2] || '';\n        if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n            // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n            const lLength = [...match[0]].length - 1;\n            let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n            const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n            endReg.lastIndex = 0;\n            // Clip maskedSrc to same section of string as src (move to lexer?)\n            maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n            while ((match = endReg.exec(maskedSrc)) != null) {\n                rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n                if (!rDelim)\n                    continue; // skip single * in __abc*abc__\n                rLength = [...rDelim].length;\n                if (match[3] || match[4]) { // found another Left Delim\n                    delimTotal += rLength;\n                    continue;\n                }\n                else if (match[5] || match[6]) { // either Left or Right Delim\n                    if (lLength % 3 && !((lLength + rLength) % 3)) {\n                        midDelimTotal += rLength;\n                        continue; // CommonMark Emphasis Rules 9-10\n                    }\n                }\n                delimTotal -= rLength;\n                if (delimTotal > 0)\n                    continue; // Haven't found enough closing delimiters\n                // Remove extra characters. *a*** -> *a*\n                rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n                // char length can be >1 for unicode characters;\n                const lastCharLength = [...match[0]][0].length;\n                const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n                // Create `em` if smallest delimiter has odd char count. *a***\n                if (Math.min(lLength, rLength) % 2) {\n                    const text = raw.slice(1, -1);\n                    return {\n                        type: 'em',\n                        raw,\n                        text,\n                        tokens: this.lexer.inlineTokens(text),\n                    };\n                }\n                // Create 'strong' if smallest delimiter has even char count. **a***\n                const text = raw.slice(2, -2);\n                return {\n                    type: 'strong',\n                    raw,\n                    text,\n                    tokens: this.lexer.inlineTokens(text),\n                };\n            }\n        }\n    }\n    codespan(src) {\n        const cap = this.rules.inline.code.exec(src);\n        if (cap) {\n            let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');\n            const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n            const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n            if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n                text = text.substring(1, text.length - 1);\n            }\n            return {\n                type: 'codespan',\n                raw: cap[0],\n                text,\n            };\n        }\n    }\n    br(src) {\n        const cap = this.rules.inline.br.exec(src);\n        if (cap) {\n            return {\n                type: 'br',\n                raw: cap[0],\n            };\n        }\n    }\n    del(src) {\n        const cap = this.rules.inline.del.exec(src);\n        if (cap) {\n            return {\n                type: 'del',\n                raw: cap[0],\n                text: cap[2],\n                tokens: this.lexer.inlineTokens(cap[2]),\n            };\n        }\n    }\n    autolink(src) {\n        const cap = this.rules.inline.autolink.exec(src);\n        if (cap) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = cap[1];\n                href = 'mailto:' + text;\n            }\n            else {\n                text = cap[1];\n                href = text;\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    url(src) {\n        let cap;\n        if (cap = this.rules.inline.url.exec(src)) {\n            let text, href;\n            if (cap[2] === '@') {\n                text = cap[0];\n                href = 'mailto:' + text;\n            }\n            else {\n                // do extended autolink path validation\n                let prevCapZero;\n                do {\n                    prevCapZero = cap[0];\n                    cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n                } while (prevCapZero !== cap[0]);\n                text = cap[0];\n                if (cap[1] === 'www.') {\n                    href = 'http://' + cap[0];\n                }\n                else {\n                    href = cap[0];\n                }\n            }\n            return {\n                type: 'link',\n                raw: cap[0],\n                text,\n                href,\n                tokens: [\n                    {\n                        type: 'text',\n                        raw: text,\n                        text,\n                    },\n                ],\n            };\n        }\n    }\n    inlineText(src) {\n        const cap = this.rules.inline.text.exec(src);\n        if (cap) {\n            const escaped = this.lexer.state.inRawBlock;\n            return {\n                type: 'text',\n                raw: cap[0],\n                text: cap[0],\n                escaped,\n            };\n        }\n    }\n}\n\n/**\n * Block Lexer\n */\nclass _Lexer {\n    tokens;\n    options;\n    state;\n    tokenizer;\n    inlineQueue;\n    constructor(options) {\n        // TokenList cannot be created in one go\n        this.tokens = [];\n        this.tokens.links = Object.create(null);\n        this.options = options || _defaults;\n        this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n        this.tokenizer = this.options.tokenizer;\n        this.tokenizer.options = this.options;\n        this.tokenizer.lexer = this;\n        this.inlineQueue = [];\n        this.state = {\n            inLink: false,\n            inRawBlock: false,\n            top: true,\n        };\n        const rules = {\n            other,\n            block: block.normal,\n            inline: inline.normal,\n        };\n        if (this.options.pedantic) {\n            rules.block = block.pedantic;\n            rules.inline = inline.pedantic;\n        }\n        else if (this.options.gfm) {\n            rules.block = block.gfm;\n            if (this.options.breaks) {\n                rules.inline = inline.breaks;\n            }\n            else {\n                rules.inline = inline.gfm;\n            }\n        }\n        this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n    static get rules() {\n        return {\n            block,\n            inline,\n        };\n    }\n    /**\n     * Static Lex Method\n     */\n    static lex(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    static lexInline(src, options) {\n        const lexer = new _Lexer(options);\n        return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    lex(src) {\n        src = src.replace(other.carriageReturn, '\\n');\n        this.blockTokens(src, this.tokens);\n        for (let i = 0; i < this.inlineQueue.length; i++) {\n            const next = this.inlineQueue[i];\n            this.inlineTokens(next.src, next.tokens);\n        }\n        this.inlineQueue = [];\n        return this.tokens;\n    }\n    blockTokens(src, tokens = [], lastParagraphClipped = false) {\n        if (this.options.pedantic) {\n            src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');\n        }\n        while (src) {\n            let token;\n            if (this.options.extensions?.block?.some((extTokenizer) => {\n                if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // newline\n            if (token = this.tokenizer.space(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (token.raw.length === 1 && lastToken !== undefined) {\n                    // if there's a single \\n as a spacer, it's terminating the last line,\n                    // so move it there so that we don't get unnecessary paragraph tags\n                    lastToken.raw += '\\n';\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.code(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                // An indented code block cannot interrupt a paragraph.\n                if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // fences\n            if (token = this.tokenizer.fences(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // heading\n            if (token = this.tokenizer.heading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // hr\n            if (token = this.tokenizer.hr(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // blockquote\n            if (token = this.tokenizer.blockquote(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // list\n            if (token = this.tokenizer.list(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // html\n            if (token = this.tokenizer.html(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // def\n            if (token = this.tokenizer.def(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.raw;\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else if (!this.tokens.links[token.tag]) {\n                    this.tokens.links[token.tag] = {\n                        href: token.href,\n                        title: token.title,\n                    };\n                }\n                continue;\n            }\n            // table (gfm)\n            if (token = this.tokenizer.table(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // lheading\n            if (token = this.tokenizer.lheading(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // top-level paragraph\n            // prevent paragraph consuming extensions by clipping 'src' to extension start\n            let cutSrc = src;\n            if (this.options.extensions?.startBlock) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startBlock.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n                const lastToken = tokens.at(-1);\n                if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                lastParagraphClipped = cutSrc.length !== src.length;\n                src = src.substring(token.raw.length);\n                continue;\n            }\n            // text\n            if (token = this.tokenizer.text(src)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'text') {\n                    lastToken.raw += '\\n' + token.raw;\n                    lastToken.text += '\\n' + token.text;\n                    this.inlineQueue.pop();\n                    this.inlineQueue.at(-1).src = lastToken.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        this.state.top = true;\n        return tokens;\n    }\n    inline(src, tokens = []) {\n        this.inlineQueue.push({ src, tokens });\n        return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */\n    inlineTokens(src, tokens = []) {\n        // String with links masked to avoid interference with em and strong\n        let maskedSrc = src;\n        let match = null;\n        // Mask out reflinks\n        if (this.tokens.links) {\n            const links = Object.keys(this.tokens.links);\n            if (links.length > 0) {\n                while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n                    if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n                        maskedSrc = maskedSrc.slice(0, match.index)\n                            + '[' + 'a'.repeat(match[0].length - 2) + ']'\n                            + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n                    }\n                }\n            }\n        }\n        // Mask out other blocks\n        while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n        }\n        // Mask out escaped characters\n        while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n            maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n        }\n        let keepPrevChar = false;\n        let prevChar = '';\n        while (src) {\n            if (!keepPrevChar) {\n                prevChar = '';\n            }\n            keepPrevChar = false;\n            let token;\n            // extensions\n            if (this.options.extensions?.inline?.some((extTokenizer) => {\n                if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n                    src = src.substring(token.raw.length);\n                    tokens.push(token);\n                    return true;\n                }\n                return false;\n            })) {\n                continue;\n            }\n            // escape\n            if (token = this.tokenizer.escape(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // tag\n            if (token = this.tokenizer.tag(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // link\n            if (token = this.tokenizer.link(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // reflink, nolink\n            if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n                src = src.substring(token.raw.length);\n                const lastToken = tokens.at(-1);\n                if (token.type === 'text' && lastToken?.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            // em & strong\n            if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // code\n            if (token = this.tokenizer.codespan(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // br\n            if (token = this.tokenizer.br(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // del (gfm)\n            if (token = this.tokenizer.del(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // autolink\n            if (token = this.tokenizer.autolink(src)) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // url (gfm)\n            if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n                src = src.substring(token.raw.length);\n                tokens.push(token);\n                continue;\n            }\n            // text\n            // prevent inlineText consuming extensions by clipping 'src' to extension start\n            let cutSrc = src;\n            if (this.options.extensions?.startInline) {\n                let startIndex = Infinity;\n                const tempSrc = src.slice(1);\n                let tempStart;\n                this.options.extensions.startInline.forEach((getStartIndex) => {\n                    tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n                    if (typeof tempStart === 'number' && tempStart >= 0) {\n                        startIndex = Math.min(startIndex, tempStart);\n                    }\n                });\n                if (startIndex < Infinity && startIndex >= 0) {\n                    cutSrc = src.substring(0, startIndex + 1);\n                }\n            }\n            if (token = this.tokenizer.inlineText(cutSrc)) {\n                src = src.substring(token.raw.length);\n                if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n                    prevChar = token.raw.slice(-1);\n                }\n                keepPrevChar = true;\n                const lastToken = tokens.at(-1);\n                if (lastToken?.type === 'text') {\n                    lastToken.raw += token.raw;\n                    lastToken.text += token.text;\n                }\n                else {\n                    tokens.push(token);\n                }\n                continue;\n            }\n            if (src) {\n                const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n                if (this.options.silent) {\n                    console.error(errMsg);\n                    break;\n                }\n                else {\n                    throw new Error(errMsg);\n                }\n            }\n        }\n        return tokens;\n    }\n}\n\n/**\n * Renderer\n */\nclass _Renderer {\n    options;\n    parser; // set by the parser\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    space(token) {\n        return '';\n    }\n    code({ text, lang, escaped }) {\n        const langString = (lang || '').match(other.notSpaceStart)?.[0];\n        const code = text.replace(other.endingNewline, '') + '\\n';\n        if (!langString) {\n            return '<pre><code>'\n                + (escaped ? code : escape(code, true))\n                + '</code></pre>\\n';\n        }\n        return '<pre><code class=\"language-'\n            + escape(langString)\n            + '\">'\n            + (escaped ? code : escape(code, true))\n            + '</code></pre>\\n';\n    }\n    blockquote({ tokens }) {\n        const body = this.parser.parse(tokens);\n        return `<blockquote>\\n${body}</blockquote>\\n`;\n    }\n    html({ text }) {\n        return text;\n    }\n    heading({ tokens, depth }) {\n        return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n    }\n    hr(token) {\n        return '<hr>\\n';\n    }\n    list(token) {\n        const ordered = token.ordered;\n        const start = token.start;\n        let body = '';\n        for (let j = 0; j < token.items.length; j++) {\n            const item = token.items[j];\n            body += this.listitem(item);\n        }\n        const type = ordered ? 'ol' : 'ul';\n        const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n        return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n    }\n    listitem(item) {\n        let itemBody = '';\n        if (item.task) {\n            const checkbox = this.checkbox({ checked: !!item.checked });\n            if (item.loose) {\n                if (item.tokens[0]?.type === 'paragraph') {\n                    item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n                    if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + escape(item.tokens[0].tokens[0].text);\n                        item.tokens[0].tokens[0].escaped = true;\n                    }\n                }\n                else {\n                    item.tokens.unshift({\n                        type: 'text',\n                        raw: checkbox + ' ',\n                        text: checkbox + ' ',\n                        escaped: true,\n                    });\n                }\n            }\n            else {\n                itemBody += checkbox + ' ';\n            }\n        }\n        itemBody += this.parser.parse(item.tokens, !!item.loose);\n        return `<li>${itemBody}</li>\\n`;\n    }\n    checkbox({ checked }) {\n        return '<input '\n            + (checked ? 'checked=\"\" ' : '')\n            + 'disabled=\"\" type=\"checkbox\">';\n    }\n    paragraph({ tokens }) {\n        return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n    }\n    table(token) {\n        let header = '';\n        // header\n        let cell = '';\n        for (let j = 0; j < token.header.length; j++) {\n            cell += this.tablecell(token.header[j]);\n        }\n        header += this.tablerow({ text: cell });\n        let body = '';\n        for (let j = 0; j < token.rows.length; j++) {\n            const row = token.rows[j];\n            cell = '';\n            for (let k = 0; k < row.length; k++) {\n                cell += this.tablecell(row[k]);\n            }\n            body += this.tablerow({ text: cell });\n        }\n        if (body)\n            body = `<tbody>${body}</tbody>`;\n        return '<table>\\n'\n            + '<thead>\\n'\n            + header\n            + '</thead>\\n'\n            + body\n            + '</table>\\n';\n    }\n    tablerow({ text }) {\n        return `<tr>\\n${text}</tr>\\n`;\n    }\n    tablecell(token) {\n        const content = this.parser.parseInline(token.tokens);\n        const type = token.header ? 'th' : 'td';\n        const tag = token.align\n            ? `<${type} align=\"${token.align}\">`\n            : `<${type}>`;\n        return tag + content + `</${type}>\\n`;\n    }\n    /**\n     * span level renderer\n     */\n    strong({ tokens }) {\n        return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n    }\n    em({ tokens }) {\n        return `<em>${this.parser.parseInline(tokens)}</em>`;\n    }\n    codespan({ text }) {\n        return `<code>${escape(text, true)}</code>`;\n    }\n    br(token) {\n        return '<br>';\n    }\n    del({ tokens }) {\n        return `<del>${this.parser.parseInline(tokens)}</del>`;\n    }\n    link({ href, title, tokens }) {\n        const text = this.parser.parseInline(tokens);\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return text;\n        }\n        href = cleanHref;\n        let out = '<a href=\"' + href + '\"';\n        if (title) {\n            out += ' title=\"' + (escape(title)) + '\"';\n        }\n        out += '>' + text + '</a>';\n        return out;\n    }\n    image({ href, title, text }) {\n        const cleanHref = cleanUrl(href);\n        if (cleanHref === null) {\n            return escape(text);\n        }\n        href = cleanHref;\n        let out = `<img src=\"${href}\" alt=\"${text}\"`;\n        if (title) {\n            out += ` title=\"${escape(title)}\"`;\n        }\n        out += '>';\n        return out;\n    }\n    text(token) {\n        return 'tokens' in token && token.tokens\n            ? this.parser.parseInline(token.tokens)\n            : ('escaped' in token && token.escaped ? token.text : escape(token.text));\n    }\n}\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nclass _TextRenderer {\n    // no need for block level renderers\n    strong({ text }) {\n        return text;\n    }\n    em({ text }) {\n        return text;\n    }\n    codespan({ text }) {\n        return text;\n    }\n    del({ text }) {\n        return text;\n    }\n    html({ text }) {\n        return text;\n    }\n    text({ text }) {\n        return text;\n    }\n    link({ text }) {\n        return '' + text;\n    }\n    image({ text }) {\n        return '' + text;\n    }\n    br() {\n        return '';\n    }\n}\n\n/**\n * Parsing & Compiling\n */\nclass _Parser {\n    options;\n    renderer;\n    textRenderer;\n    constructor(options) {\n        this.options = options || _defaults;\n        this.options.renderer = this.options.renderer || new _Renderer();\n        this.renderer = this.options.renderer;\n        this.renderer.options = this.options;\n        this.renderer.parser = this;\n        this.textRenderer = new _TextRenderer();\n    }\n    /**\n     * Static Parse Method\n     */\n    static parse(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    static parseInline(tokens, options) {\n        const parser = new _Parser(options);\n        return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    parse(tokens, top = true) {\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions?.renderers?.[anyToken.type]) {\n                const genericToken = anyToken;\n                const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n                if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'space': {\n                    out += this.renderer.space(token);\n                    continue;\n                }\n                case 'hr': {\n                    out += this.renderer.hr(token);\n                    continue;\n                }\n                case 'heading': {\n                    out += this.renderer.heading(token);\n                    continue;\n                }\n                case 'code': {\n                    out += this.renderer.code(token);\n                    continue;\n                }\n                case 'table': {\n                    out += this.renderer.table(token);\n                    continue;\n                }\n                case 'blockquote': {\n                    out += this.renderer.blockquote(token);\n                    continue;\n                }\n                case 'list': {\n                    out += this.renderer.list(token);\n                    continue;\n                }\n                case 'html': {\n                    out += this.renderer.html(token);\n                    continue;\n                }\n                case 'paragraph': {\n                    out += this.renderer.paragraph(token);\n                    continue;\n                }\n                case 'text': {\n                    let textToken = token;\n                    let body = this.renderer.text(textToken);\n                    while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n                        textToken = tokens[++i];\n                        body += '\\n' + this.renderer.text(textToken);\n                    }\n                    if (top) {\n                        out += this.renderer.paragraph({\n                            type: 'paragraph',\n                            raw: body,\n                            text: body,\n                            tokens: [{ type: 'text', raw: body, text: body, escaped: true }],\n                        });\n                    }\n                    else {\n                        out += body;\n                    }\n                    continue;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    parseInline(tokens, renderer = this.renderer) {\n        let out = '';\n        for (let i = 0; i < tokens.length; i++) {\n            const anyToken = tokens[i];\n            // Run any renderer extensions\n            if (this.options.extensions?.renderers?.[anyToken.type]) {\n                const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n                if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n                    out += ret || '';\n                    continue;\n                }\n            }\n            const token = anyToken;\n            switch (token.type) {\n                case 'escape': {\n                    out += renderer.text(token);\n                    break;\n                }\n                case 'html': {\n                    out += renderer.html(token);\n                    break;\n                }\n                case 'link': {\n                    out += renderer.link(token);\n                    break;\n                }\n                case 'image': {\n                    out += renderer.image(token);\n                    break;\n                }\n                case 'strong': {\n                    out += renderer.strong(token);\n                    break;\n                }\n                case 'em': {\n                    out += renderer.em(token);\n                    break;\n                }\n                case 'codespan': {\n                    out += renderer.codespan(token);\n                    break;\n                }\n                case 'br': {\n                    out += renderer.br(token);\n                    break;\n                }\n                case 'del': {\n                    out += renderer.del(token);\n                    break;\n                }\n                case 'text': {\n                    out += renderer.text(token);\n                    break;\n                }\n                default: {\n                    const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n                    if (this.options.silent) {\n                        console.error(errMsg);\n                        return '';\n                    }\n                    else {\n                        throw new Error(errMsg);\n                    }\n                }\n            }\n        }\n        return out;\n    }\n}\n\nclass _Hooks {\n    options;\n    block;\n    constructor(options) {\n        this.options = options || _defaults;\n    }\n    static passThroughHooks = new Set([\n        'preprocess',\n        'postprocess',\n        'processAllTokens',\n    ]);\n    /**\n     * Process markdown before marked\n     */\n    preprocess(markdown) {\n        return markdown;\n    }\n    /**\n     * Process HTML after marked is finished\n     */\n    postprocess(html) {\n        return html;\n    }\n    /**\n     * Process all tokens before walk tokens\n     */\n    processAllTokens(tokens) {\n        return tokens;\n    }\n    /**\n     * Provide function to tokenize markdown\n     */\n    provideLexer() {\n        return this.block ? _Lexer.lex : _Lexer.lexInline;\n    }\n    /**\n     * Provide function to parse tokens\n     */\n    provideParser() {\n        return this.block ? _Parser.parse : _Parser.parseInline;\n    }\n}\n\nclass Marked {\n    defaults = _getDefaults();\n    options = this.setOptions;\n    parse = this.parseMarkdown(true);\n    parseInline = this.parseMarkdown(false);\n    Parser = _Parser;\n    Renderer = _Renderer;\n    TextRenderer = _TextRenderer;\n    Lexer = _Lexer;\n    Tokenizer = _Tokenizer;\n    Hooks = _Hooks;\n    constructor(...args) {\n        this.use(...args);\n    }\n    /**\n     * Run callback for every token\n     */\n    walkTokens(tokens, callback) {\n        let values = [];\n        for (const token of tokens) {\n            values = values.concat(callback.call(this, token));\n            switch (token.type) {\n                case 'table': {\n                    const tableToken = token;\n                    for (const cell of tableToken.header) {\n                        values = values.concat(this.walkTokens(cell.tokens, callback));\n                    }\n                    for (const row of tableToken.rows) {\n                        for (const cell of row) {\n                            values = values.concat(this.walkTokens(cell.tokens, callback));\n                        }\n                    }\n                    break;\n                }\n                case 'list': {\n                    const listToken = token;\n                    values = values.concat(this.walkTokens(listToken.items, callback));\n                    break;\n                }\n                default: {\n                    const genericToken = token;\n                    if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n                        this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n                            const tokens = genericToken[childTokens].flat(Infinity);\n                            values = values.concat(this.walkTokens(tokens, callback));\n                        });\n                    }\n                    else if (genericToken.tokens) {\n                        values = values.concat(this.walkTokens(genericToken.tokens, callback));\n                    }\n                }\n            }\n        }\n        return values;\n    }\n    use(...args) {\n        const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };\n        args.forEach((pack) => {\n            // copy options to new object\n            const opts = { ...pack };\n            // set async to true if it was set to true before\n            opts.async = this.defaults.async || opts.async || false;\n            // ==-- Parse \"addon\" extensions --== //\n            if (pack.extensions) {\n                pack.extensions.forEach((ext) => {\n                    if (!ext.name) {\n                        throw new Error('extension name required');\n                    }\n                    if ('renderer' in ext) { // Renderer extensions\n                        const prevRenderer = extensions.renderers[ext.name];\n                        if (prevRenderer) {\n                            // Replace extension with func to run new extension but fall back if false\n                            extensions.renderers[ext.name] = function (...args) {\n                                let ret = ext.renderer.apply(this, args);\n                                if (ret === false) {\n                                    ret = prevRenderer.apply(this, args);\n                                }\n                                return ret;\n                            };\n                        }\n                        else {\n                            extensions.renderers[ext.name] = ext.renderer;\n                        }\n                    }\n                    if ('tokenizer' in ext) { // Tokenizer Extensions\n                        if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n                            throw new Error(\"extension level must be 'block' or 'inline'\");\n                        }\n                        const extLevel = extensions[ext.level];\n                        if (extLevel) {\n                            extLevel.unshift(ext.tokenizer);\n                        }\n                        else {\n                            extensions[ext.level] = [ext.tokenizer];\n                        }\n                        if (ext.start) { // Function to check for start of token\n                            if (ext.level === 'block') {\n                                if (extensions.startBlock) {\n                                    extensions.startBlock.push(ext.start);\n                                }\n                                else {\n                                    extensions.startBlock = [ext.start];\n                                }\n                            }\n                            else if (ext.level === 'inline') {\n                                if (extensions.startInline) {\n                                    extensions.startInline.push(ext.start);\n                                }\n                                else {\n                                    extensions.startInline = [ext.start];\n                                }\n                            }\n                        }\n                    }\n                    if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n                        extensions.childTokens[ext.name] = ext.childTokens;\n                    }\n                });\n                opts.extensions = extensions;\n            }\n            // ==-- Parse \"overwrite\" extensions --== //\n            if (pack.renderer) {\n                const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n                for (const prop in pack.renderer) {\n                    if (!(prop in renderer)) {\n                        throw new Error(`renderer '${prop}' does not exist`);\n                    }\n                    if (['options', 'parser'].includes(prop)) {\n                        // ignore options property\n                        continue;\n                    }\n                    const rendererProp = prop;\n                    const rendererFunc = pack.renderer[rendererProp];\n                    const prevRenderer = renderer[rendererProp];\n                    // Replace renderer with func to run extension, but fall back if false\n                    renderer[rendererProp] = (...args) => {\n                        let ret = rendererFunc.apply(renderer, args);\n                        if (ret === false) {\n                            ret = prevRenderer.apply(renderer, args);\n                        }\n                        return ret || '';\n                    };\n                }\n                opts.renderer = renderer;\n            }\n            if (pack.tokenizer) {\n                const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n                for (const prop in pack.tokenizer) {\n                    if (!(prop in tokenizer)) {\n                        throw new Error(`tokenizer '${prop}' does not exist`);\n                    }\n                    if (['options', 'rules', 'lexer'].includes(prop)) {\n                        // ignore options, rules, and lexer properties\n                        continue;\n                    }\n                    const tokenizerProp = prop;\n                    const tokenizerFunc = pack.tokenizer[tokenizerProp];\n                    const prevTokenizer = tokenizer[tokenizerProp];\n                    // Replace tokenizer with func to run extension, but fall back if false\n                    // @ts-expect-error cannot type tokenizer function dynamically\n                    tokenizer[tokenizerProp] = (...args) => {\n                        let ret = tokenizerFunc.apply(tokenizer, args);\n                        if (ret === false) {\n                            ret = prevTokenizer.apply(tokenizer, args);\n                        }\n                        return ret;\n                    };\n                }\n                opts.tokenizer = tokenizer;\n            }\n            // ==-- Parse Hooks extensions --== //\n            if (pack.hooks) {\n                const hooks = this.defaults.hooks || new _Hooks();\n                for (const prop in pack.hooks) {\n                    if (!(prop in hooks)) {\n                        throw new Error(`hook '${prop}' does not exist`);\n                    }\n                    if (['options', 'block'].includes(prop)) {\n                        // ignore options and block properties\n                        continue;\n                    }\n                    const hooksProp = prop;\n                    const hooksFunc = pack.hooks[hooksProp];\n                    const prevHook = hooks[hooksProp];\n                    if (_Hooks.passThroughHooks.has(prop)) {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (arg) => {\n                            if (this.defaults.async) {\n                                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                                    return prevHook.call(hooks, ret);\n                                });\n                            }\n                            const ret = hooksFunc.call(hooks, arg);\n                            return prevHook.call(hooks, ret);\n                        };\n                    }\n                    else {\n                        // @ts-expect-error cannot type hook function dynamically\n                        hooks[hooksProp] = (...args) => {\n                            let ret = hooksFunc.apply(hooks, args);\n                            if (ret === false) {\n                                ret = prevHook.apply(hooks, args);\n                            }\n                            return ret;\n                        };\n                    }\n                }\n                opts.hooks = hooks;\n            }\n            // ==-- Parse WalkTokens extensions --== //\n            if (pack.walkTokens) {\n                const walkTokens = this.defaults.walkTokens;\n                const packWalktokens = pack.walkTokens;\n                opts.walkTokens = function (token) {\n                    let values = [];\n                    values.push(packWalktokens.call(this, token));\n                    if (walkTokens) {\n                        values = values.concat(walkTokens.call(this, token));\n                    }\n                    return values;\n                };\n            }\n            this.defaults = { ...this.defaults, ...opts };\n        });\n        return this;\n    }\n    setOptions(opt) {\n        this.defaults = { ...this.defaults, ...opt };\n        return this;\n    }\n    lexer(src, options) {\n        return _Lexer.lex(src, options ?? this.defaults);\n    }\n    parser(tokens, options) {\n        return _Parser.parse(tokens, options ?? this.defaults);\n    }\n    parseMarkdown(blockType) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const parse = (src, options) => {\n            const origOpt = { ...options };\n            const opt = { ...this.defaults, ...origOpt };\n            const throwError = this.onError(!!opt.silent, !!opt.async);\n            // throw error if an extension set async to true but parse was called with async: false\n            if (this.defaults.async === true && origOpt.async === false) {\n                return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n            }\n            // throw error in case of non string input\n            if (typeof src === 'undefined' || src === null) {\n                return throwError(new Error('marked(): input parameter is undefined or null'));\n            }\n            if (typeof src !== 'string') {\n                return throwError(new Error('marked(): input parameter is of type '\n                    + Object.prototype.toString.call(src) + ', string expected'));\n            }\n            if (opt.hooks) {\n                opt.hooks.options = opt;\n                opt.hooks.block = blockType;\n            }\n            const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n            const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n            if (opt.async) {\n                return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n                    .then(src => lexer(src, opt))\n                    .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n                    .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n                    .then(tokens => parser(tokens, opt))\n                    .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n                    .catch(throwError);\n            }\n            try {\n                if (opt.hooks) {\n                    src = opt.hooks.preprocess(src);\n                }\n                let tokens = lexer(src, opt);\n                if (opt.hooks) {\n                    tokens = opt.hooks.processAllTokens(tokens);\n                }\n                if (opt.walkTokens) {\n                    this.walkTokens(tokens, opt.walkTokens);\n                }\n                let html = parser(tokens, opt);\n                if (opt.hooks) {\n                    html = opt.hooks.postprocess(html);\n                }\n                return html;\n            }\n            catch (e) {\n                return throwError(e);\n            }\n        };\n        return parse;\n    }\n    onError(silent, async) {\n        return (e) => {\n            e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n            if (silent) {\n                const msg = '<p>An error occurred:</p><pre>'\n                    + escape(e.message + '', true)\n                    + '</pre>';\n                if (async) {\n                    return Promise.resolve(msg);\n                }\n                return msg;\n            }\n            if (async) {\n                return Promise.reject(e);\n            }\n            throw e;\n        };\n    }\n}\n\nconst markedInstance = new Marked();\nfunction marked(src, opt) {\n    return markedInstance.parse(src, opt);\n}\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\n    marked.setOptions = function (options) {\n        markedInstance.setOptions(options);\n        marked.defaults = markedInstance.defaults;\n        changeDefaults(marked.defaults);\n        return marked;\n    };\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\nmarked.defaults = _defaults;\n/**\n * Use Extension\n */\nmarked.use = function (...args) {\n    markedInstance.use(...args);\n    marked.defaults = markedInstance.defaults;\n    changeDefaults(marked.defaults);\n    return marked;\n};\n/**\n * Run callback for every token\n */\nmarked.walkTokens = function (tokens, callback) {\n    return markedInstance.walkTokens(tokens, callback);\n};\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\nconst options = marked.options;\nconst setOptions = marked.setOptions;\nconst use = marked.use;\nconst walkTokens = marked.walkTokens;\nconst parseInline = marked.parseInline;\nconst parse = marked;\nconst parser = _Parser.parse;\nconst lexer = _Lexer.lex;\n\nexport { _Hooks as Hooks, _Lexer as Lexer, Marked, _Parser as Parser, _Renderer as Renderer, _TextRenderer as TextRenderer, _Tokenizer as Tokenizer, _defaults as defaults, _getDefaults as getDefaults, lexer, marked, options, parse, parseInline, parser, setOptions, use, walkTokens };\n//# sourceMappingURL=marked.esm.js.map\n","import { marked } from 'marked';\nimport type { BlogPost, MDXPost, MarkdownPost, BlogLoadError } from '../types/blog.types';\n\n// Raw markdown content for .md files\nconst rawMdPosts: Record<string, string> = import.meta.glob('/src/blogs/*.md', {\n  eager: true,\n  query: '?raw',\n  import: 'default',\n}) as Record<string, string>;\n\n/**\n * Load MDX files using Vite's import system\n */\nexport async function loadMDXPosts(): Promise<MDXPost[]> {\n  const posts: MDXPost[] = [];\n  \n  try {\n    // Import MDX files directly - Vite will handle the compilation\n    const modules = import.meta.glob('/src/blogs/*.mdx', { eager: true });\n    \n    console.log('MDX modules found:', Object.keys(modules));\n    \n    for (const [path, module] of Object.entries(modules)) {\n      try {\n        const slug = path.replace('/src/blogs/', '').replace('.mdx', '');\n        const mdxModule = module as any;\n        \n        console.log(`Processing MDX module: ${slug}`, mdxModule);\n        \n        // Check if this is a valid MDX module\n        if (mdxModule.default && typeof mdxModule.default === 'function') {\n          const post: MDXPost = {\n            slug,\n            title: mdxModule.title || mdxModule.default.title || slug.replace(/-/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase()),\n            date: mdxModule.date || mdxModule.default.date || new Date().toISOString().split('T')[0],\n            excerpt: mdxModule.excerpt || mdxModule.default.excerpt || '',\n            thumbnail: mdxModule.thumbnail || mdxModule.default.thumbnail,\n            content: mdxModule.default,\n            type: 'mdx'\n          };\n          \n          console.log(`Created MDX post:`, post);\n          posts.push(post);\n        } else {\n          console.warn(`MDX module at ${path} does not have a valid default export`, mdxModule);\n        }\n      } catch (error) {\n        const loadError: BlogLoadError = new Error(`Error processing MDX file ${path}`) as BlogLoadError;\n        loadError.slug = path.replace('/src/blogs/', '').replace('.mdx', '');\n        loadError.path = path;\n        loadError.type = 'compile';\n        loadError.cause = error;\n        \n        console.error('MDX processing error:', loadError);\n      }\n    }\n  } catch (error) {\n    const loadError: BlogLoadError = new Error('Error loading MDX files') as BlogLoadError;\n    loadError.type = 'load';\n    loadError.cause = error;\n    \n    console.error('MDX loading error:', loadError);\n  }\n  \n  return posts.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n}\n\n/**\n * Load markdown posts from .md files\n */\nexport async function loadMarkdownPosts(): Promise<MarkdownPost[]> {\n  const posts: MarkdownPost[] = [];\n\n  try {\n    // Process markdown files\n    for (const path in rawMdPosts) {\n      try {\n        const raw = rawMdPosts[path];\n        if (!raw) {\n          throw new Error(`No content found for ${path}`);\n        }\n        const filename = path.split('/').pop() || '';\n        const slug = filename.replace(/\\.md$/, '');\n        \n        // Normalize line endings\n        const normalizedContent = raw.replace(/\\r\\n/g, '\\n');\n        \n        // Extract front matter with more robust regex\n        const frontMatterMatch = normalizedContent.match(/^---\\s*\\n([\\s\\S]*?)\\n---\\s*\\n/);\n        const frontMatter = frontMatterMatch ? frontMatterMatch[1] : '';\n        const mainContent = normalizedContent.replace(/^---\\s*\\n[\\s\\S]*?\\n---\\s*\\n/, '').trim();\n        \n        // Improved front matter parsing with optional whitespace\n        const getFrontMatterValue = (key: string): string => {\n          if (!frontMatter) return '';\n          const match = frontMatter.match(new RegExp(`${key}:\\\\s*(.+?)\\\\s*(?:\\\\n|$)`));\n          return match?.[1]?.trim() || '';\n        };\n\n        const dateValue = getFrontMatterValue('date');\n        const thumbnailValue = getFrontMatterValue('thumbnail');\n        const post: MarkdownPost = {\n          slug,\n          title: getFrontMatterValue('title') || slug.replace(/-/g, ' ').replace(/\\b\\w/g, l => l.toUpperCase()),\n          date: dateValue || new Date().toISOString().split('T')[0]!,\n          excerpt: getFrontMatterValue('excerpt') || '',\n          ...(thumbnailValue && { thumbnail: thumbnailValue }),\n          content: mainContent,\n          type: 'md',\n        };\n\n        console.debug(`Parsed markdown post \"${path}\"`, post);\n        posts.push(post);\n      } catch (error) {\n        const loadError: BlogLoadError = new Error(`Error parsing MD post ${path}`) as BlogLoadError;\n        const filename = path.split('/').pop();\n        if (filename) {\n          loadError.slug = filename.replace(/\\.md$/, '');\n        }\n        loadError.path = path;\n        loadError.type = 'parse';\n        loadError.cause = error;\n        \n        console.error('Markdown parsing error:', loadError);\n      }\n    }\n  } catch (error) {\n    const loadError: BlogLoadError = new Error('Error loading markdown files') as BlogLoadError;\n    loadError.type = 'load';\n    loadError.cause = error;\n    \n    console.error('Markdown loading error:', loadError);\n  }\n\n  // Sort by date, newest first\n  return posts.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n}\n\n/**\n * Combined function to load all posts (MDX + Markdown)\n */\nexport async function loadAllPosts(): Promise<BlogPost[]> {\n  console.log('Loading all posts...');\n  \n  const [mdxPosts, markdownPosts] = await Promise.all([\n    loadMDXPosts(),\n    loadMarkdownPosts()\n  ]);\n  \n  console.log(`Loaded ${mdxPosts.length} MDX posts and ${markdownPosts.length} markdown posts`);\n  \n  // Remove duplicates by slug (MDX takes precedence over MD)\n  const allPosts = [...mdxPosts, ...markdownPosts];\n  const uniquePosts = allPosts.filter((post, index, arr) =>\n    arr.findIndex(p => p.slug === post.slug) === index\n  );\n  \n  const sortedPosts = uniquePosts.sort((a, b) =>\n    new Date(b.date).getTime() - new Date(a.date).getTime()\n  );\n  \n  console.log('All posts (deduplicated):', sortedPosts);\n  \n  return sortedPosts;\n}\n\n/**\n * Function to get a specific post by slug\n */\nexport async function getPostBySlug(slug: string): Promise<BlogPost | null> {\n  console.log(`Getting post by slug: ${slug}`);\n  \n  try {\n    const allPosts = await loadAllPosts();\n    const post = allPosts.find(post => post.slug === slug) || null;\n    \n    if (post && post.type === 'md') {\n      // Transform image paths and convert markdown to HTML\n      const transformedContent = (post.content as string).replace(\n        /!\\[(.*?)\\]\\((?!http|\\/)(.*?)\\)/g,\n        (_m, alt, img) => `![${alt}](/assets/img/blog-post-imgs/${post.slug}/${img})`\n      );\n      \n      // Convert markdown to HTML for display\n      const htmlContent = await marked(transformedContent);\n      (post as MarkdownPost).content = htmlContent;\n    }\n    \n    console.log(`Found post:`, post);\n    return post;\n  } catch (error) {\n    const loadError: BlogLoadError = new Error(`Error getting post by slug: ${slug}`) as BlogLoadError;\n    loadError.slug = slug;\n    loadError.type = 'load';\n    loadError.cause = error;\n    \n    console.error('Get post error:', loadError);\n    return null;\n  }\n}\n\n/**\n * Search posts by title, excerpt, or content\n */\nexport async function searchPosts(query: string): Promise<BlogPost[]> {\n  if (!query.trim()) return [];\n  \n  try {\n    const allPosts = await loadAllPosts();\n    const searchTerm = query.toLowerCase();\n    \n    return allPosts.filter(post => \n      post.title.toLowerCase().includes(searchTerm) ||\n      post.excerpt.toLowerCase().includes(searchTerm) ||\n      (post.type === 'md' && (post.content as string).toLowerCase().includes(searchTerm))\n    );\n  } catch (error) {\n    console.error('Search posts error:', error);\n    return [];\n  }\n}\n\n/**\n * Get posts by date range\n */\nexport async function getPostsByDateRange(startDate: string, endDate: string): Promise<BlogPost[]> {\n  try {\n    const allPosts = await loadAllPosts();\n    const start = new Date(startDate);\n    const end = new Date(endDate);\n    \n    return allPosts.filter(post => {\n      const postDate = new Date(post.date);\n      return postDate >= start && postDate <= end;\n    });\n  } catch (error) {\n    console.error('Get posts by date range error:', error);\n    return [];\n  }\n}\n\n// Export types for backward compatibility\nexport type { BlogPost, MDXPost, MarkdownPost };\n\n// Re-export for backward compatibility with existing imports\nexport { loadAllPosts as loadBlogPosts };"],"names":["src","alt","caption","children","_jsx","_components","code","_jsxs","ul","a","jsx","br","pre","em","_getDefaults","async","breaks","extensions","gfm","hooks","pedantic","renderer","silent","tokenizer","walkTokens","_defaults","changeDefaults","newDefaults","noopTest","exec","edit","regex","opt","source","obj","replace","name","val","valSource","other","caret","getRegex","RegExp","codeRemoveIndent","outputLinkReplace","indentCodeCompensation","beginningSpace","endingHash","startingSpaceChar","endingSpaceChar","nonSpaceChar","newLineCharGlobal","tabCharGlobal","multipleSpaceGlobal","blankLine","doubleBlankLine","blockquoteStart","blockquoteSetextReplace","blockquoteSetextReplace2","listReplaceTabs","listReplaceNesting","listIsTask","listReplaceTask","anyLine","hrefBrackets","tableDelimiter","tableAlignChars","tableRowBlankLine","tableAlignRight","tableAlignCenter","tableAlignLeft","startATag","endATag","startPreScriptTag","endPreScriptTag","startAngleBracket","endAngleBracket","pedanticHrefTitle","unicodeAlphaNumeric","escapeTest","escapeReplace","escapeTestNoEncode","escapeReplaceNoEncode","unescapeTest","percentDecode","findPipe","splitPipe","slashPipe","carriageReturn","spaceLine","notSpaceStart","endingNewline","listItemRegex","bull","nextBulletRegex","indent","Math","min","hrRegex","fencesBeginRegex","headingBeginRegex","htmlBeginRegex","hr","bullet","lheadingCore","lheading","lheadingGfm","_paragraph","_blockLabel","def","list","_tag","_comment","html","paragraph","blockNormal","blockquote","fences","heading","newline","table","text","gfmTable","blockGfm","blockPedantic","_punctuation","_punctuationOrSpace","_notPunctuationOrSpace","punctuation","_punctuationGfmStrongEm","emStrongLDelimCore","emStrongLDelim","emStrongLDelimGfm","emStrongRDelimAstCore","emStrongRDelimAst","emStrongRDelimAstGfm","emStrongRDelimUnd","anyPunctuation","autolink","_inlineComment","tag","_inlineLabel","link","reflink","nolink","inlineNormal","_backpedal","blockSkip","del","escape","reflinkSearch","url","inlinePedantic","inlineGfm","inlineBreaks","block","normal","inline","escapeReplacements","getEscapeReplacement","ch","encode","test","cleanUrl","href","encodeURI","splitCells","tableRow","count","cells","match","offset","str","escaped","curr","split","i","trim","shift","length","at","pop","splice","push","rtrim","c","invert","l","suffLen","charAt","slice","outputLink","cap","raw","lexer","rules","title","state","inLink","token","type","tokens","inlineTokens","_Tokenizer","constructor","options","__publicField","this","space","codeBlockStyle","matchIndentToCode","indentToCode","map","node","matchIndentInNode","indentInNode","join","lang","trimmed","depth","lines","inBlockquote","currentLines","currentRaw","currentText","top","blockTokens","lastToken","oldToken","newText","newToken","substring","isordered","ordered","start","loose","items","itemRegex","endsWithBlankLine","endEarly","itemContents","line","t","repeat","nextLine","trimStart","search","rawLine","nextLineWithoutTabs","ischecked","istask","task","checked","lastItem","trimEnd","spacers","filter","hasMultipleLineBreaks","some","toLowerCase","headers","aligns","rows","item","header","align","row","cell","inRawBlock","trimmedUrl","rtrimSlash","lastParenIndex","b","indexOf","level","findClosingBracket","linkLen","links","emStrong","maskedSrc","prevChar","lLength","rDelim","rLength","delimTotal","midDelimTotal","endReg","lastIndex","lastCharLength","index","codespan","hasNonSpaceChars","hasSpaceCharsOnBothEnds","prevCapZero","inlineText","_Lexer","Object","create","inlineQueue","lex","lexInline","next","lastParagraphClipped","extTokenizer","call","cutSrc","startBlock","startIndex","Infinity","tempSrc","tempStart","forEach","getStartIndex","errMsg","charCodeAt","Error","keys","includes","lastIndexOf","keepPrevChar","startInline","_Renderer","langString","parser","parse","parseInline","body","j","listitem","itemBody","checkbox","unshift","tablecell","tablerow","k","content","strong","cleanHref","out","image","_TextRenderer","_Parser","textRenderer","anyToken","renderers","genericToken","ret","textToken","_Hooks","preprocess","markdown","postprocess","processAllTokens","provideLexer","provideParser","Set","markedInstance","args","setOptions","parseMarkdown","use","callback","values","concat","tableToken","listToken","defaults","childTokens","flat","pack","opts","ext","prevRenderer","apply","extLevel","prop","rendererProp","rendererFunc","tokenizerProp","tokenizerFunc","prevTokenizer","hooksProp","hooksFunc","prevHook","passThroughHooks","has","arg","Promise","resolve","then","packWalktokens","blockType","origOpt","throwError","onError","prototype","toString","all","catch","e","message","msg","reject","marked","getDefaults","Parser","Renderer","TextRenderer","Lexer","Tokenizer","Hooks","rawMdPosts","assign","loadMDXPosts","posts","modules","__vite_glob_1_0","__vite_glob_1_1","__vite_glob_1_2","path","module","entries","slug","mdxModule","default","post","toUpperCase","date","Date","toISOString","excerpt","thumbnail","error","loadError","cause","sort","getTime","loadMarkdownPosts","normalizedContent","frontMatterMatch","frontMatter","mainContent","getFrontMatterValue","key","dateValue","thumbnailValue","filename","loadAllPosts","mdxPosts","markdownPosts","arr","findIndex","p","getPostBySlug","find","transformedContent","_m","img","htmlContent"],"mappings":"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","x_google_ignoreList":[3]}